#!/usr/bin/perl

=head1 NAME

git-list-pr - A tool to list GitHub pull requests and choose one to checkout

=head1 SYNOPSIS

    # launch fzf and choose one to checkout
    git list-pr

    # print all active PRs
    git list-pr -p

=head1 DESCRIPTION

This script uses the GitHub CLI (C<gh>) to retrieve a list of pull requests for
the current repository. It formats and displays the list with color-coded
output and users can select the one interactively using C<fzf> and check it
out.

If C<fzf> does not exist in your env or B<-p> option is supplied, it only
prints out the list.

=head1 OPTIONS

=over 4

=item B<-p>, B<--print>

Print out the list and not launch selector by C<fzf>. This is the default when
C<fzf> does not exist.

=item B<-s>, B<--search-options>=I<options>

This will be used to filter the pull requests. It is passed directly to
C<gh pr list>.

=item B<-w>, B<--web>

Open the selected pull request in the web browser instead of checking it out.

=item B<-f>, B<--fzf-options>

Add options to use with C<fzf>.

Examples:

    git list-pr -f '--height=50%'

    # use default options for fzf
    git list-pr -f $FZF_DEFAULT_OPTS

=item B<-h>, B<--help>

Show this help message.

=back

=cut

use 5.34.0;
use warnings;
use feature 'signatures';
no warnings 'experimental::signatures';
use utf8;
use File::Which qw(which);
use Getopt::Long qw(:config posix_default no_ignore_case bundling auto_help);
use JSON;
use Path::Tiny qw(path);
use Pod::Usage qw(pod2usage);
use Term::ANSIColor qw(:constants);
use Time::Piece;
use List::Util qw(max min sum);
binmode STDERR, ":utf8";
binmode STDOUT, ":utf8";

my %opt = (
    'fzf-options' => '',
    'search-options' => '',
);
GetOptions(
    \%opt, qw(
    fzf-options|f=s
    print|p
    search-options|s=s
    web|w
    help|h
)) or pod2usage(1);
$opt{help} and pod2usage(0);
which 'git' or pod2usage({ -message => 'git not found', -exitval => 2});
which 'gh' or pod2usage({ -message => 'gh not found', -exitval => 2});

if (!$opt{print} && !which 'fzf') {
    warn "fzf not found\n";
    $opt{print}++;
}

my $decoded = eval { decode_json `gh pr list $opt{'search-options'} --json number,title,headRefName,author,createdAt,isDraft,additions,deletions,changedFiles` };
if ($@) {
    warn "Failed to decode JSON: $@";
    exit 1;
}

my $emoji = eval {
    my $cache_file = '/tmp/github_emoji.json';
    if (-e $cache_file) {
        decode_json path($cache_file)->slurp;
    } else {
        my $json = decode_json `gh api -H 'Accept: application/vnd.github.v3+json' /emojis`;
        for (keys $json->%*) {
            $json->{$_} =~ s|.*/([-\da-f]+)\.png.*|
                join '', map { chr hex } split /-/, $1;
            |e;
        }
        path($cache_file)->spew(encode_json $json);
        $json;
    }
};
die "Failed to load emojis: $@" if $@;

sub default_branches {
    map {
        my $epoch = (split /\n/, `git log origin/$_ --reverse --pretty=format:'%ct'`)[0];
        {
            additions => 0,
            author => { login => 'system' },
            changedFiles => 0,
            createdAt => gmtime($epoch)->strftime('%FT%TZ'),
            deletions => 0,
            headRefName => $_,
            isDraft => 0,
            number => 0,
            title => $_,
        }
    } sort map { s,.*origin/,,; $_ } grep {
        m,^  origin/(?:main|master|develop|staging)$,
    } split /\n/, `git branch -r`;
}

my @prs = $decoded->@*;
push @prs, default_branches if !$opt{'search-options'};

sub term_width {
    return $ENV{COLUMNS} if $ENV{COLUMNS};
    # ioctl on /dev/tty to get real terminal width (backticks make stdout a pipe,
    # so tput cols cannot detect it via ioctl on stdout)
    if (open my $tty, '<', '/dev/tty') {
        my $winsize = "\0" x 8;
        # TIOCGWINSZ: macOS=0x40087468, Linux=0x5413
        my $TIOCGWINSZ = $^O eq 'darwin' ? 0x40087468 : 0x5413;
        if (ioctl($tty, $TIOCGWINSZ, $winsize)) {
            my ($rows, $cols) = unpack('SS', $winsize);
            close $tty;
            return $cols if $cols > 0;
        }
        close $tty;
    }
    chomp(my $w = `tput cols 2>/dev/null`);
    $w || 80;
}

sub fzf_margin {
    return 0 if $opt{print};
    my $all_opts = ($ENV{FZF_DEFAULT_OPTS} // '') . ' ' . $opt{'fzf-options'};
    my $margin = 2; # fzf pointer/indicator

    # --border detection (last specified value wins)
    my $style = '';
    while ($all_opts =~ /--border(?:=(\S+))?/g) {
        $style = $1 // 'rounded';
    }
    if ($style =~ /^(rounded|sharp|bold|double|block|thinblock|vertical)$/) {
        $margin += 2; # left + right borders
    } elsif ($style =~ /^(left|right)$/) {
        $margin += 1;
    }
    # horizontal, top, bottom, none: no horizontal increase

    # --padding detection (add left+right)
    if ($all_opts =~ /--padding[= ]'?([^'"\s]+)'?/g) {
        my @parts = split /,/, $1;
        if (@parts == 1)    { $margin += $parts[0] * 2 }
        elsif (@parts == 2) { $margin += $parts[1] * 2 }
        elsif (@parts >= 4) { $margin += $parts[1] + $parts[3] }
    }

    $margin;
}

sub display_width($str) {
    my $w = 0;
    for (split //, $str) {
        $w += /\p{EA=W}/ ? 2 : 1;
    }
    $w;
}

sub truncate_pad($str, $width) {
    return '' if $width <= 0;
    my $dw = display_width($str);
    if ($dw <= $width) {
        return $str . ' ' x ($width - $dw);
    }
    return "\x{2026}" if $width == 1;
    my $w = 0;
    my $result = '';
    for my $ch (split //, $str) {
        my $cw = $ch =~ /\p{EA=W}/ ? 2 : 1;
        last if $w + $cw > $width - 1;
        $result .= $ch;
        $w += $cw;
    }
    $result .= "\x{2026}";
    $w++;
    $result .= ' ' x ($width - $w) if $w < $width;
    $result;
}

for (@prs) {
    $_->{title} =~ s|:(\w+):|$emoji->{$1} // $&|eg;
    $_->{authorName} = $_->{author}{login} // 'unknown';
}

my $add_w = max map { length "$_->{additions}" } @prs;
my $del_w = max map { length "$_->{deletions}" } @prs;
my $file_w = max map { length "$_->{changedFiles}" } @prs;
my $num_d = max 4, max map { length "$_->{number}" } @prs;

# Required fixed width (always shown): "#N  " + "+N/-N"
my $required = ($num_d + 3) + ($add_w + $del_w + 3);

# Droppable fixed columns (drop order)
my @droppable_fixed = (
    { name => 'files', width => $file_w + 10 },  # "  N files  "
    { name => 'date',  width => 22 },             # "  " + 20 chars
);

# Variable columns (truncation order: title first, branch last)
my @variable = (
    { name => 'title',       min => 15 },
    { name => 'authorName',  min => 6  },
    { name => 'headRefName', min => 12 },
);

# Natural widths for variable columns
my %nat_w;
for my $name (qw(authorName title headRefName)) {
    $nat_w{$name} = max map { display_width($_->{$name}) } @prs;
}

# Track which columns are visible
my %show = (files => 1, date => 1, title => 1, authorName => 1);
my %col_w;

my $eff_width = term_width() - fzf_margin();
my $base_avail = $eff_width - $required; # space after required columns

# Compute available space for variable column content from current %show state
my $compute_avail = sub {
    my $a = $base_avail;
    for my $df (@droppable_fixed) {
        $a -= $df->{width} if $show{$df->{name}};
    }
    my @vis = grep { $show{$_->{name}} // 1 } @variable;
    $a -= scalar(@vis) * 2; # separators
    $a;
};

# Try to fit variable columns into given avail, truncating in priority order.
# Returns true if fitted.
my $try_fit = sub($avail, @cols) {
    my $nat_total = sum map { $nat_w{$_->{name}} } @cols;
    if ($nat_total <= $avail) {
        $col_w{$_->{name}} = $nat_w{$_->{name}} for @cols;
        return 1;
    }
    for my $i (0 .. $#cols) {
        my $v = $cols[$i];
        my $others = 0;
        for my $j (0 .. $#cols) {
            next if $i == $j;
            $others += $col_w{$cols[$j]{name}} // $nat_w{$cols[$j]{name}};
        }
        my $this_w = max($v->{min}, $avail - $others);
        $col_w{$v->{name}} = min($this_w, $nat_w{$v->{name}});
        my $total = sum map { $col_w{$_->{name}} // $nat_w{$_->{name}} } @cols;
        if ($total <= $avail) {
            for my $j ($i + 1 .. $#cols) {
                $col_w{$cols[$j]{name}} //= $nat_w{$cols[$j]{name}};
            }
            return 1;
        }
    }
    return 0;
};

# Phase 1 & 2: try fitting all variable columns
if (!$try_fit->($compute_avail->(), @variable)) {
    # Phase 3: drop columns until it fits
    for my $v (@variable) {
        $col_w{$v->{name}} = $v->{min};
    }

    my @droppable_all = (
        { name => 'files',      type => 'fixed' },
        { name => 'date',       type => 'fixed' },
        { name => 'title',      type => 'variable' },
        { name => 'authorName', type => 'variable' },
    );

    for my $drop (@droppable_all) {
        # Check if current state fits
        my @visible_var = grep { $show{$_->{name}} // 1 } @variable;
        my $avail = $compute_avail->();
        my $total = sum map { $col_w{$_->{name}} } @visible_var;
        last if $total <= $avail;

        # Drop this column
        $show{$drop->{name}} = 0;
        delete $col_w{$drop->{name}} if $drop->{type} eq 'variable';

        # Re-run Phase 2 on remaining visible variable columns
        @visible_var = grep { $show{$_->{name}} // 1 } @variable;
        last if $try_fit->($compute_avail->(), @visible_var);
    }
}

for my $pr (@prs) {
    for my $name (qw(authorName title headRefName)) {
        next unless $col_w{$name};
        $pr->{formatted}{$name} = truncate_pad($pr->{$name}, $col_w{$name});
    }
}

my $build_line = sub($pr) {
    my $line = '';
    $line .= ($pr->{isDraft} ? BRIGHT_BLACK : GREEN)
           . sprintf("#%-${num_d}d  ", $pr->{number}) . RESET;
    $line .= MAGENTA . $pr->{formatted}{authorName} . "  " . RESET
        if $show{authorName};
    $line .= $pr->{formatted}{title} . "  "
        if $show{title};
    $line .= CYAN . $pr->{formatted}{headRefName} . "  " . RESET;
    $line .= GREEN . sprintf("+%${add_w}d", $pr->{additions})
           . RESET . "/"
           . RED . sprintf("-%${del_w}d", $pr->{deletions}) . RESET;
    $line .= sprintf("  %${file_w}d files", $pr->{changedFiles})
        if $show{files};
    $line .= "  " . BRIGHT_BLACK . $pr->{createdAt} . RESET
        if $show{date};
    $line . "\n";
};

my $result = join '', map { $build_line->($_) } @prs;

if ($opt{print}) {
    print $result;
    exit;
}

my $temp = Path::Tiny->tempfile;
$temp->spew_utf8($result);
my $fzf_opts = $opt{'fzf-options'} =~ /--ansi/  ? $opt{'fzf-options'} : "--ansi $opt{'fzf-options'}";
my $selected = `bash -c "cat $temp | fzf $fzf_opts"`;
if ($? != 0) {
    die "cancelled\n";
    exit $?;
}
my ($num, $ref) = $selected =~ /^#(\d+).*\s+(\S+)\s+\+\d+\/-\d+/;
if ($num == 0) {
    exec 'sh', '-c', "git checkout $ref && git pull origin $ref && git submodule update --init --recursive";
} elsif ($opt{web}) {
    exec 'gh', 'pr', 'view', '-w', $num;
} else {
    exec 'gh', 'co', '--recurse-submodules', $num;
}
